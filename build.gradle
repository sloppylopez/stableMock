plugins {
    id 'java-library'
    id 'java-gradle-plugin'
    id 'jacoco'  // Code coverage
    id 'signing'  // Required for GPG signing
    id 'com.vanniktech.maven.publish' version '0.34.0'
}

group = 'com.stablemock'
version = '1.1.1'

sourceCompatibility = '17'
targetCompatibility = '17'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
    // Note: com.vanniktech.maven.publish plugin automatically creates javadoc and sources jars
}

repositories {
    mavenCentral()
}

dependencies {
    // Upgraded to WireMock 3.13.2 to fix CVE-2023-44487 (HTTP/2 Rapid Reset vulnerability)
    api 'org.wiremock:wiremock-standalone:3.13.2'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.15.2'
    implementation 'io.github.java-diff-utils:java-diff-utils:4.12'

    // SLF4J API for logging (consumers provide their own implementation)
    api 'org.slf4j:slf4j-api:2.0.9'
    // Simple implementation only for tests (not transitive to consumers)
    testRuntimeOnly 'org.slf4j:slf4j-simple:2.0.9'

    implementation platform('org.junit:junit-bom:5.9.3')
    api 'org.junit.jupiter:junit-jupiter-api:5.9.3'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.3'

    // Spring dependencies for BaseStableMockTest (compileOnly so valid for compilation, 
    // but consumers must provide their own Spring versions)
    compileOnly 'org.springframework.boot:spring-boot-starter-test:3.1.5'
    compileOnly 'org.springframework:spring-test:6.0.13'
}

gradlePlugin {
    plugins {
        stablemock {
            id = 'com.stablemock'
            implementationClass = 'com.stablemock.gradle.StableMockPlugin'
        }
    }
}

test {
    useJUnitPlatform()

    // System properties passed via -D flag are available via System.getProperty()
    // This works cross-platform (Windows PowerShell, bash, etc.)
    systemProperty 'stablemock.mode',
        System.getProperty('stablemock.mode', System.getenv('STABLEMOCK_MODE') ?: '')

    systemProperty 'stablemock.showMatches',
        System.getProperty('stablemock.showMatches', '')

    // Exclude XML E2E tests from regular test runs (they require RECORD mode first)
    if (!project.hasProperty('includeXmlE2E')) {
        exclude '**/XmlE2ETest.class'
    }

    // Restore parallel execution - JaCoCo errors are harmless warnings
    maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
}

// JaCoCo Code Coverage
jacoco {
    toolVersion = "0.8.12"
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                '**/gradle/**'  // Exclude Gradle plugin classes from coverage if desired
            ])
        }))
    }
}

// Javadoc configuration
javadoc {
    options.encoding = 'UTF-8'
    options.addStringOption('Xdoclint:none', '-quiet')
    if (JavaVersion.current().isJava9Compatible()) {
        options.addBooleanOption('html5', true)
    }
}

tasks.withType(Jar).configureEach {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

// Signing configuration
// Supports both file-based (from gradle.properties) and in-memory (from environment variables)
signing {
    // Disable signing for Maven Local publishing
    required { !gradle.taskGraph.hasTask("publishToMavenLocal") }
}

// Configure signing signatory after project evaluation (to ensure env vars are available)
afterEvaluate {
    // Check if in-memory signing is available (from environment variables in CI/CD)
    // Gradle converts ORG_GRADLE_PROJECT_* env vars to project properties
    def inMemoryKey = project.findProperty('signingInMemoryKey')
    def inMemoryKeyId = project.findProperty('signingInMemoryKeyId')
    def inMemoryKeyPassword = project.findProperty('signingInMemoryKeyPassword')
    
    println "=== Signing Configuration Debug ==="
    println "signingInMemoryKey present: ${inMemoryKey != null}"
    println "signingInMemoryKeyId present: ${inMemoryKeyId != null}"
    println "signingInMemoryKeyId value: ${inMemoryKeyId}"
    
    if (inMemoryKey && inMemoryKeyId) {
        println "Configuring in-memory GPG signing (CI/CD mode)"
        println "Key ID: ${inMemoryKeyId}"
        println "Key length: ${inMemoryKey.length()} characters"
        
        // Decode base64 if needed (GitHub Secrets are base64-encoded)
        def decodedKey = inMemoryKey
        try {
            // Try to decode base64 (if it's base64-encoded)
            if (!inMemoryKey.contains('-----BEGIN PGP')) {
                println "Decoding base64-encoded GPG key..."
                decodedKey = new String(java.util.Base64.decoder.decode(inMemoryKey))
                println "Decoded key length: ${decodedKey.length()} characters"
                println "Decoded key starts with: ${decodedKey.take(50)}..."
            } else {
                println "Key appears to be already decoded (contains PGP header)"
            }
        } catch (Exception e) {
            println "Base64 decoding failed, using key as-is: ${e.message}"
            decodedKey = inMemoryKey
        }
        
        try {
            // Ensure key is properly formatted (trim and ensure it has proper line endings)
            def formattedKey = decodedKey.trim()
            if (!formattedKey.endsWith('\n')) {
                formattedKey = formattedKey + '\n'
            }
            
            // Configure in-memory signing within the signing extension
            signing.useInMemoryPgpKeys(inMemoryKeyId, formattedKey, inMemoryKeyPassword)
            println "âœ“ In-memory GPG signing configured successfully"
        } catch (Exception e) {
            println "ERROR: Failed to configure in-memory GPG signing"
            println "Exception: ${e.class.name}: ${e.message}"
            println "Stack trace:"
            e.printStackTrace()
            if (e.cause) {
                println "Cause: ${e.cause.message}"
            }
            throw new GradleException("Failed to configure in-memory GPG signing: ${e.message}", e)
        }
    } else {
        println "In-memory signing not available, using file-based signing from gradle.properties"
        println "Available properties: signingInMemoryKey=${inMemoryKey != null}, signingInMemoryKeyId=${inMemoryKeyId != null}"
        // Debug: List all signing-related properties
        def signingProps = project.properties.findAll { it.key.startsWith('signing') }
        if (signingProps) {
            println "Signing-related properties found: ${signingProps.keySet()}"
        } else {
            println "No signing-related properties found in project"
        }
        // If in-memory keys are not provided, the signing plugin automatically uses
        // file-based signing from ~/.gradle/gradle.properties:
        // - signing.keyId (e.g., B7CD1441480535FA)
        // - signing.password (GPG passphrase)
        // - signing.secretKeyRingFile (e.g., C:/Users/sergi/.gnupg/secring.gpg)
    }
    println "=== End Signing Configuration Debug ==="
}

// Fix task dependency issue between java-gradle-plugin and maven-publish plugin
afterEvaluate {
    def generateMetadataTask = tasks.findByName('generateMetadataFileForPluginMavenPublication')
    def plainJavadocJarTask = tasks.findByName('plainJavadocJar')
    if (generateMetadataTask && plainJavadocJarTask) {
        generateMetadataTask.dependsOn(plainJavadocJarTask)
    }
    
    // Disable signing tasks when publishing to Maven Local
    def isPublishingToMavenLocal = gradle.startParameter.taskNames.any { 
        it.toLowerCase().contains('mavenlocal') || it.toLowerCase().contains('publishtomavenlocal')
    }
    
    if (isPublishingToMavenLocal) {
        tasks.matching { it.name.contains('sign') && it.name.contains('Publication') }.configureEach {
            enabled = false
        }
    }
}

// Configure Maven Central publishing via Central Portal
// Plugin automatically reads from ~/.gradle/gradle.properties:
// - mavenCentralUsername, mavenCentralPassword
// - signing.keyId, signing.password, signing.secretKeyRingFile (for GPG signing)
mavenPublishing {
    publishToMavenCentral()
    signAllPublications()

    coordinates(project.group.toString(), 'stablemock', project.version.toString())

    pom {
        name = 'StableMock'
        description = 'A JUnit 5 extension that uses WireMock to record and replay HTTP requests and responses during tests, with support for ignoring dynamic data.'
        inceptionYear = '2025'
        url = 'https://github.com/sloppylopez/stablemock'
        licenses {
            license {
                name = 'MIT License'
                url = 'https://opensource.org/licenses/MIT'
                distribution = 'repo'
            }
        }
        developers {
            developer {
                id = 'sloppylopez'
                name = 'Sloppy Lopez'
                url = 'https://github.com/sloppylopez'
            }
        }
        scm {
            url = 'https://github.com/sloppylopez/stablemock'
            connection = 'scm:git:git://github.com/sloppylopez/stablemock.git'
            developerConnection = 'scm:git:ssh://git@github.com:sloppylopez/stablemock.git'
        }
    }
}
